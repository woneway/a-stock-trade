# 回测系统技术方案调研报告

> 详细对比：接入现有框架 vs 自建方案

---

## 一、现有成熟框架调研

### 1.1 主流回测框架对比

| 框架 | 类型 | Stars | 最后更新 | 维护状态 | 适用场景 |
|------|------|-------|----------|----------|----------|
| **Backtrader** | 事件驱动 | 16.3K | 2年前 | 活跃 | 通用/教学 |
| **Zipline** | 事件驱动 | 18.2K | 5年前 | 停滞 | 学术研究 |
| **PyAlgoTrade** | 事件驱动 | 4.5K | 7年前 | 存档 | 轻量学习 |
| **VectorBT** | 向量化 | 8.2K | 活跃 | 活跃 | 高频/批量 |
| **vnpy** | 事件驱动 | 23K+ | 活跃 | 活跃 | 实盘交易 |

### 1.2 详细框架分析

#### Backtrader（推荐）

**架构特点**：
- 事件驱动型框架
- 面向对象API设计
- 支持多数据源、多策略、多周期

**核心组件**：
```
Cerebro (大脑) → Data Feed → Strategy → Broker → Sizer → Analyzer
```

**优点**：
- ✅ 文档最完善，中文资料丰富
- ✅ 内置talib技术指标支持
- ✅ 支持参数自动优化
- ✅ 多品种、多策略、多周期
- ✅ 支持pyfolio、empyrica分析模块
- ✅ 可扩展TensorFlow、PyTorch集成

**缺点**：
- ❌ 回测速度较慢（14万行数据约30秒）
- ❌ 图表功能简单
- ❌ **无内置涨跌停处理**（A股重大坑）
- ❌ 无机器学习集成

**A股适用性**：
- ⚠️ 需要自行处理涨跌停限制
- ⚠️ 需要处理T+1交易制度
- ⚠️ 滑点模型需自定义

**成本**：免费开源

---

#### VectorBT

**架构特点**：
- 向量化运算，底层NumPy/Pandas
- 支持GPU并行计算（需CUDA）

**优点**：
- ✅ 回测速度极快（1000只股票10年数据<1分钟）
- ✅ 多资产组合优化
- ✅ 内置夏普比率、最大回撤等分析
- ✅ 适合批量策略测试

**缺点**：
- ❌ 策略需完全向量化，对新手不友好
- ❌ 社区小，中文文档稀缺
- ❌ 无法模拟真实交易环境

**A股适用性**：
- ⚠️ 同样需处理涨跌停
- ❌ 不适合事件驱动策略

**成本**：免费开源

---

#### vnpy

**架构特点**：
- 事件驱动 + C++底层
- 兼顾回测与实盘

**优点**：
- ✅ 支持多策略、多品种
- ✅ 支持实盘交易对接
- ✅ 多周期处理比backtrader优雅
- ✅ 中文社区活跃

**缺点**：
- ❌ 文档相对较少
- ❌ 学习曲线陡峭
- ❌ 图表功能有限

**A股适用性**：
- ⚠️ 需要配置A通接口
- ⚠️ 同样需处理涨跌停

**成本**：免费开源

---

### 1.3 框架能力对比矩阵

| 能力 | Backtrader | VectorBT | vnpy | Zipline |
|------|------------|----------|------|---------|
| **事件驱动** | ✅ | ❌ | ✅ | ✅ |
| **向量化速度** | ❌ | ✅ | ❌ | ❌ |
| **多周期** | ✅ | ✅ | ✅ | ✅ |
| **多策略** | ✅ | ✅ | ✅ | ✅ |
| **参数优化** | ✅ | ✅ | ✅ | ✅ |
| **技术指标** | ✅(talib) | ✅ | ✅ | ✅ |
| **风险分析** | ✅ | ✅ | ✅ | ✅ |
| **实盘对接** | ⚠️ | ❌ | ✅ | ❌ |
| **中文文档** | ✅ | ❌ | ✅ | ❌ |
| **A股支持** | ⚠️ | ⚠️ | ⚠️ | ❌ |

---

## 二、自建方案调研

### 2.1 自建方案类型

| 类型 | 实现难度 | 回测速度 | 灵活性 | 适用场景 |
|------|----------|----------|--------|----------|
| **向量化** | 低 | 快 | 低 | 简单策略 |
| **事件驱动** | 高 | 慢 | 高 | 复杂策略 |
| **混合架构** | 高 | 中 | 高 | 专业级 |

### 2.2 事件驱动自建架构

```
┌─────────────────────────────────────────────────────────┐
│                    EventQueue (事件队列)                  │
└─────────────────────────────────────────────────────────┘
                          ↑
    ┌─────────────────────┼─────────────────────┐
    │                     │                     │
    ▼                     ▼                     ▼
┌──────────┐       ┌──────────┐       ┌──────────┐
│  Data    │       │ Strategy │       │ Portfolio│
│ Handler  │       │ Engine   │       │ Manager  │
└──────────┘       └──────────┘       └──────────┘
    │                     │                     │
    └─────────────────────┼─────────────────────┘
                          │
                          ▼
                 ┌──────────────┐
                 │   Broker     │
                 │  (模拟成交)  │
                 └──────────────┘
```

### 2.3 自建核心模块

```python
# 事件定义
class Event:
    MARKET = "market"
    SIGNAL = "signal"
    ORDER = "order"
    FILL = "fill"

# 数据处理器
class DataHandler:
    def get_latest_bars(self, symbol, N=1):
        """获取最近N条K线"""
        pass

# 策略引擎
class Strategy:
    def calculate_signal(self):
        """计算交易信号"""
        pass

# 仓位管理
class Portfolio:
    def update_position(self, fill_event):
        """更新仓位"""
        pass

# 订单执行
class Broker:
    def execute_order(self, order):
        """模拟订单执行"""
        # 处理涨跌停
        # 处理滑点
        # 处理T+1
        pass
```

### 2.4 A股特殊处理

```python
class AShareBroker(Broker):
    def __init__(self):
        self.limit_up_stocks = set()  # 当日涨停股票
        self.limit_down_stocks = set()  # 当日跌停股票
        self.t1_locked = {}  # T+1锁定股票

    def can_buy(self, symbol, price):
        """是否能买入"""
        # 1. 检查是否涨停
        if symbol in self.limit_up_stocks:
            return False, "涨停无法买入"
        # 2. 检查是否T+1
        if symbol in self.t1_locked:
            return False, "T+1无法卖出"
        return True, None

    def can_sell(self, symbol, price):
        """是否能卖出"""
        # 1. 检查是否跌停
        if symbol in self.limit_down_stocks:
            return False, "跌停无法卖出"
        # 2. 检查是否T+1
        if symbol in self.t1_locked:
            return False, "T+1无法卖出"
        return True, None

    def execute_order(self, order):
        """执行订单"""
        # 计算实际成交价（考虑滑点）
        exec_price = self.calculate_slippage(order.price)

        # 检查涨跌停
        can_trade, reason = self.check_tradeable(order.symbol, exec_price)
        if not can_trade:
            return FillEvent(status="rejected", reason=reason)

        return FillEvent(status="filled", price=exec_price)
```

---

## 三、详细对比分析

### 3.1 功能对比

| 对比项 | Backtrader | 自建方案 |
|--------|------------|----------|
| **实施周期** | 1-2周 | 4-8周 |
| **开发成本** | 低 | 高 |
| **学习成本** | 中 | 高 |
| **灵活性** | 中 | 高 |
| **A股涨跌停** | 需自行实现 | 完全可控 |
| **T+1制度** | 需自行实现 | 完全可控 |
| **滑点模型** | 基础 | 可定制 |
| **游资策略** | 需改造 | 完全定制 |
| **维护成本** | 低 | 高 |

### 3.2 性能对比

| 场景 | Backtrader | 自建向量化 | 自建事件驱动 |
|------|------------|------------|--------------|
| 单策略1年 | 30秒 | 5秒 | 2分钟 |
| 100股10年 | 数小时 | 1分钟 | 数小时 |
| 参数优化 | 支持 | 需自行实现 | 需自行实现 |

### 3.3 成本对比

| 成本项 | Backtrader | 自建方案 |
|--------|------------|----------|
| **开发人力** | 1周 | 4-8周 |
| **学习培训** | 1周 | 2周 |
| **维护成本** | 低 | 高 |
| **扩展成本** | 中 | 低 |
| **问题解决** | 社区支持 | 自行解决 |

---

## 四、推荐方案

### 4.1 方案一：基于Backtrader扩展（推荐）

**适用场景**：
- 快速上线
- 资源有限
- 通用策略

**实施步骤**：
```
1. 安装backtrader (pip install backtrader)
2. 接入Tushare数据源
3. 扩展AShareBroker处理A股规则
4. 编写策略模板
5. 对接现有系统
```

**核心扩展代码**：
```python
import backtrader as bt

class AShareStrategy(bt.Strategy):
    """A股专用策略模板"""

    def __init__(self):
        self.order = None
        self.limit_up = set()  # 今日涨停
        self.limit_down = set()  # 今日跌停

    def notify_order(self, order):
        if order.status in [order.Submitted, order.Accepted]:
            return

        if order.status in [order.Completed]:
            if order.isbuy():
                self.log(f'买入执行: {order.executed.price}')
            elif order.issell():
                self.log(f'卖出执行: {order.executed.price}')

        self.order = None

    def next(self):
        # 跳过涨跌停股票
        if self.data._name in self.limit_up:
            return
        if self.data._name in self.limit_down:
            return

        # 原有策略逻辑
        if not self.position:
            if self.should_buy():
                self.buy()
        else:
            if self.should_sell():
                self.sell()

# A股Broker扩展
class AShareBroker(bt.brokers.BrokerBase):
    """处理A股特殊规则"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.limit_up_pct = 10  # 涨停幅度
        self.t1_stocks = {}  # T+1股票池

    def _submit_order(self, order):
        # 检查涨跌停
        # 检查T+1
        # 计算滑点
        pass
```

**工作量估算**：
- 基础框架搭建：3天
- 数据接入：2天
- A股规则处理：3天
- 策略迁移：2天
- **总计：约10天**

---

### 4.2 方案二：自建轻量级回测

**适用场景**：
- 特殊需求
- 完全可控
- 长期维护

**实施步骤**：
```
1. 设计事件驱动架构
2. 实现数据层（对接Tushare）
3. 实现策略引擎
4. 实现仓位管理
5. 实现成交模拟
6. 实现分析模块
```

**核心代码结构**：
```python
# 核心类设计
class BacktestEngine:
    def __init__(self, initial_cash=1000000):
        self.cash = initial_cash
        self.positions = {}
        self.events = Queue()
        self.data_handler = None
        self.strategy = None
        self.portfolio = None
        self.broker = None

    def run(self, start_date, end_date):
        """运行回测"""
        while self.data_handler.has_next():
            # 1. 生成市场事件
            self.events.put(MarketEvent())

            # 2. 处理事件
            while not self.events.empty():
                event = self.events.get()
                self.process_event(event)

            # 3. 推进时间
            self.data_handler.next()

    def process_event(self, event):
        if event.type == Event.MARKET:
            # 更新数据
            self.strategy.update()
            # 生成信号
            signal = self.strategy.generate_signal()
            if signal:
                self.events.put(SignalEvent(signal))

        elif event.type == Event.SIGNAL:
            # 生成订单
            order = self.portfolio.process_signal(event.signal)
            if order:
                self.events.put(OrderEvent(order))

        elif event.type == Event.ORDER:
            # 执行订单
            fill = self.broker.execute(order)
            self.events.put(FillEvent(fill))
            # 更新仓位
            self.portfolio.update_position(fill)
```

**工作量估算**：
- 架构设计：3天
- 数据层：3天
- 策略引擎：5天
- 成交模拟：5天
- 分析模块：3天
- **总计：约20天**

---

### 4.3 方案三：向量化快速验证

**适用场景**：
- 策略快速验证
- 批量参数测试
- 简单策略

**代码示例**：
```python
import pandas as pd
import numpy as np
import akshare as ak

def vector_backtest(symbol, start_date, end_date):
    # 1. 获取数据
    df = ak.stock_zh_a_hist(symbol, start_date, end_date)

    # 2. 计算信号
    df['ma5'] = df['收盘'].rolling(5).mean()
    df['ma20'] = df['收盘'].rolling(20).mean()
    df['signal'] = np.where(df['ma5'] > df['ma20'], 1, 0)
    df['signal'] = df['signal'].diff()

    # 3. 计算收益
    df['return'] = df['收盘'].pct_change()
    df['strategy_return'] = df['signal'].shift(1) * df['return']

    # 4. 统计结果
    total_return = (1 + df['strategy_return']).prod() - 1
    annual_return = (1 + total_return) ** (252 / len(df)) - 1

    return {
        'total_return': total_return,
        'annual_return': annual_return,
        'max_drawdown': (df['strategy_return'].cumsum() - df['strategy_return'].cumsum().cummax()).min()
    }
```

**工作量**：1-2天

---

## 五、综合建议

### 5.1 选择决策树

```
是否需要特殊A股处理（涨跌停、T+1）？
    │
    ├─ 否 → 简单策略 → 向量化方案（1-2天）
    │
    └─ 是 → 是否有特殊策略需求？
              │
              ├─ 否 → Backtrader扩展（2周）
              │
              └─ 是 → 是否有定制化需求？
                        │
                        ├─ 否 → Backtrader深度定制（3周）
                        │
                        └─ 是 → 自建方案（4-8周）
```

### 5.2 推荐最终方案

**针对本项目（游资交易系统）**：

| 阶段 | 方案 | 时间 | 理由 |
|------|------|------|------|
| MVP | Backtrader扩展 | 2周 | 快速上线、验证需求 |
| 正式版 | 自建轻量级 | 4周 | A股规则完整支持 |
| 高级版 | 自建完整版 | 8周 | 完全可控、长期维护 |

**MVP阶段推荐Backtrader扩展**：
1. 现有系统已有策略框架
2. 可快速对接Tushare数据
3. 社区支持丰富
4. 先验证需求，再决定是否自建

---

## 六、总结

### 6.1 方案对比一览

| 维度 | Backtrader | 向量化 | 自建事件驱动 |
|------|------------|--------|--------------|
| 上手难度 | ⭐⭐ | ⭐ | ⭐⭐⭐⭐ |
| 开发周期 | 2周 | 1周 | 6周 |
| A股支持 | ⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐⭐ |
| 性能 | ⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐ |
| 灵活性 | ⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐⭐ |
| 维护成本 | 低 | 低 | 高 |
| 推荐度 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ |

### 6.2 最终建议

**本项目建议分阶段实施**：

1. **第一阶段（2周）**：基于Backtrader快速实现
   - 对接Tushare数据
   - 扩展A股规则
   - 迁移现有策略

2. **第二阶段（4周）**：根据需求决定
   - 如果Backtrader满足需求 → 持续优化
   - 如果需求特殊 → 考虑自建轻量级

3. **第三阶段（持续）**：根据使用情况
   - 用户量大 → 考虑性能优化
   - 需求复杂 → 扩展自建功能

---

*本报告基于公开资料调研产出，具体实施需根据实际情况调整。*
